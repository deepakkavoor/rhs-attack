import random
# random.seed(0)
import itertools
import time
from quadtree import get_quadtree, xmin, xmax, ymin, ymax

# Overview:
# RV (the driver) sends information A_ij (permuted w.r.t j) for i=1..m, j=1..4 to RS (the SP)
# RS knows EN_ij values and p
# Goal: SP can eliminate shared randomness between A_ij1 and A_ij2 and obtains an equation
# of (x_rv, y_rv) for each A_ij. Then find (x_rv, y_rv) using two such equations and
# find that permutation which gives consistency with all other A_ij equations 


# Default parameters from TRACE paper:
# number of quad tree nodes m: 50 or 100
# k1 = 512, k2 = 160, k3 = 75, k4 = 75 or
# k1=2048, k2 = 1000, k3 = 400, k4 = 400
# prime |p| = k1 = 512
# prime |alpha| = k2 = 160
# s is in Zp*
# |a_jh| = k3 = 75 (j=1..4, h=1..6)
# |r_ij| = k4 = 75
(k1,k2,k3,k4) = (512,160,75,75)
#(k1,k2,k3,k4) = (2048,1000,400,400)
m_max = 53
#m_max = 101

def get_random_coordinate():
    # get a random positive [x,y] coordinate
    return [random.randint(xmin, xmax), random.randint(ymin, ymax)]

def modinv(x,p):
    # when p is prime. return inverse of x modulo p
    return pow(x, p-2, p)

def get_random_shuffle(A):
    # A is list of size 4. use for debug
    l = list(range(4))
    random.shuffle(l)
    A_copy = A.copy()
    for j in range(4):
        A_copy[j] = A[l[j]]
    return A_copy

def two_intersection(l1, l2):
    # given lists l1, l2 return a list of intersection
    l = []
    for l1i in l1:
        if l1i in l2 and l1i not in l:
            l.append(l1i)
    return l

def multi_intersection(L):
    # L is a list of lists. return intersection of Li for all i
    if len(L) == 0:
        return []
    l = L[0]
    for i in range(1, len(L)):
        l = two_intersection(l, L[i])
    return l


# other way to generate large primes, use this website: https://asecuritysite.com/encryption/random3
# example: (k1=512, k2=160)
# p = 2610012493187751553850229270260260188412785728466825936469473849183260172904846529218774317876204989248256766513760785264139183325575284012588127483034783
# alpha = 805054899696897334540366748238814746338336769857

def rs_attack_rv():

    # Generated by RS: p, alpham, s, a_ji, N, EN
    # Fix some parameters
    p = random_prime(2**k1-1, False, 2**(k1-1))
    alpha = random_prime(2**k2-1, False, 2**(k2-1))

    s = random.randint(0,p-1)
    sinv = modinv(s,p)

    print('RS generating a_jh')
    a = []
    for j in range(4):
        a_j = []
        for h in range(6):
            a_j.append(random.randint(1<<(k3-1),1<<k3-1))
        a.append(a_j)

    print('RS generating N_i')
    N = get_quadtree(m_max)
    print('len of N', len(N))
    m = len(N)

    print('RS generating EN_i')
    EN = []
    for i in range(m):
        EN_i = []
        for j in range(4):
            j_nxt = (j + 1 ) % 4
            [x_Nij, y_Nij] = N[i][j]
            [x_Nijnxt, y_Nijnxt] = N[i][j_nxt]
            EN_ij1 = s*(x_Nij * alpha + a[j][0]) % p
            EN_ij2 = s*(y_Nij * alpha + a[j][1]) % p
            EN_ij3 = s*(x_Nijnxt * alpha + a[j][2]) % p
            EN_ij4 = s*(y_Nijnxt * alpha + a[j][3]) % p
            EN_ij5 = s*(x_Nij * y_Nijnxt * alpha + a[j][4]) % p
            EN_ij6 = s*(x_Nijnxt * y_Nij * alpha + a[j][5]) % p
            EN_ij = [EN_ij1, EN_ij2, EN_ij3, EN_ij4, EN_ij5, EN_ij6]
            EN_i.append(EN_ij)
        EN.append(EN_i)


    # Generated by RV: [xv, yv], A
    print('RV generating xv, yv')
    [xv, yv] = get_random_coordinate()

    print('RV generating A_ij1, A_ij2')
    A = []
    for i in range(m):
        A_i = []
        for j in range(4):
            r_ij = random.randint(1<<(k4-1),1<<k4-1)
            A_ij1 = r_ij * alpha * (xv * EN[i][j][3] + yv * EN[i][j][0] + EN[i][j][5]) % p
            A_ij2 = r_ij * alpha * (xv * EN[i][j][1] + yv * EN[i][j][2] + EN[i][j][4]) % p
            A_ij = [A_ij1, A_ij2]
            A_i.append(A_ij)
        # shuffle
        random.shuffle(A_i)
        A.append(A_i)


    # RS gets: A, knows: EN, tries to find: [xv, yv]
    # but there could be many such valid candidate coordinates for each A_i
    # so, take the common candidate among all A_i's

    print('RS trying to find xv, yv')
    valid_xy = []

    for i in range(m):
        # RS doesn't know which permutation of A_i is correct, so try all
        all_perms = list(itertools.permutations(A[i]))
        valid_xy_i = []   # among the 24 permutations for given i, some [x,y] may satisfy even for incorrect permutation 
        perm_counter = 1
        for perm in all_perms:
            Ai = perm
            # for each j, eliminate rij, alpha from Aij1, Aij2
            # to obtain an equation of the form mx + ny = k
            # use j=1,2 to solve for x,y and j=3,4 to verify consistency
            m = []
            n = []
            k = []
            for j in range(4):
                m.append(Ai[j][0]*EN[i][j][1] - Ai[j][1]*EN[i][j][3])
                n.append(Ai[j][0]*EN[i][j][2] - Ai[j][1]*EN[i][j][0])
                k.append(Ai[j][1]*EN[i][j][5] - Ai[j][0]*EN[i][j][4])
            # find x,y using first two values of m,n,k
            x = (n[1]*k[0]-n[0]*k[1])*modinv(m[0]*n[1]-m[1]*n[0], p) % p
            y = (m[1]*k[0]-m[0]*k[1])*modinv(n[0]*m[1]-n[1]*m[0], p) % p
            # verify consistency
            check1 = ((m[2]*x + n[2]*y)%p == k[2]%p)
            check2 = ((m[3]*x + n[3]*y)%p == k[3]%p)
            if check1 and check2:
                valid_xy_i.append([x,y])
            perm_counter += 1
        valid_xy.append(valid_xy_i)

    print("original  :", [[xv, yv]])

    success = False
    l = multi_intersection(valid_xy)
    if len(l)==1 and l[0] == [xv, yv]:
        success = True
    elif len(l) > 1 and [xv, yv] in l:
        print('Len is >1 but original solution is among them')
    return success


if __name__ == '__main__':

    num_trials = 30
    num_success = 0
    avg_time = 0
    max_time = 0
    print('Params m:',m_max)
    print('Params (k1,k2,k3,k4):',(k1,k2,k3,k4))
    for i in range(1, num_trials+1):
        start = time.time()
        success = rs_attack_rv()
        if success:
            print('====================Trial', i, 'successful====================')
            num_success += 1
            max_time = max(max_time, time.time()-start)
            avg_time += (time.time()-start)
        else:
            print('====================Trial', i, 'unsuccessful====================')
        print('Max time for successful attack (sec):', max_time)
    if num_success > 0:
        avg_time /= num_success
    print('Final success rate:', num_success, '/', num_trials, '(', num_success/num_trials*100, '%)')
    print('Avg time for successful attack (sec):', avg_time)



